from random import randrange
from time import clock 
from Line import Line 

num_lines = 10 
def genLines(n,P):
	slopes = []
	intercepts = []
	for i in range(0,n):
		rand_slope = randrange(-n,n)
		while slopes.count(rand_slope) != 0:
			rand_slope = randrange(-n,n)
		slopes.append(rand_slope)
		intercepts.append(randrange(-n,n))
	slopes.sort() 	
	for i in range(0,n):
		x = Line()
		P.append(x) 
		P[i].m = slopes[i] 
		P[i].b = intercepts[i]
def intercept(l1,l2):
 	x = (l1.b - l2.b) / (l2.m - l1.m)
	return x

def mergeLines(L,R):
	for i in range(1, len(L)-1):
		Lx1 = intercept(L[i],L[i-1])
		Lx2 = intercept(L[i],L[i+1])
		L[i].dom = [Lx1, Lx2] 
		for k in range(len(R)-2,1,-1):
			Rx1 = intercept(R[k],R[k-1])
			Rx2 = intercept(R[k],R[k+1])
			R[k].dom = [Rx1,Rx2]
		if((Lx1 <= Rx1 <= Lx1) or (Lx1 <= Rx2 <= Lx2)):
			j = i -1 
			Yjxjk = L[j].m * (L[j].b - R[k].b) + L[j].b * (R[k].m - L[j].m)
			Yixjk = L[i].m * (L[j].b-R[k].b) + L[i].b * (R[k].m-L[j].m)
			if(Yjxjk < Yixjk):
				for z in range(z,len(L)):
					L[z].vis = False
	for i in range(len(R)-2,1,-1):
		Rx1 = intercept(R[i],R[i-1])
		Rx1 = intercept(R[i],R[i+1])
		R[i].dom = [Rx1,Rx2]
		for j in range(1,len(L)-1):
			Lx1 = intercept([j],L[j-1])
			Lx2 = intercept(L[j],L[j+1])
			L[j].dom = [Lx1,Lx2]
			if((Rx1 <= Lx1 <= Rx2) or (Rx1 <= Lx2 <= Rx2)):
				k = i+1
				Yjxjk = L[j].m * (L[j].b - R[k].b) + L[j].b * (R[k].m - L[j].m)
				Yixjk = R[i].m * (L[j].b - R[k].b) + R[i].b * (R[k].m - L[j].m)
				if(Yjxjk < Yixjk):
                                	for z in range(z,len(L)):
						L[z].vis = False
	return L.extend(R)


def alg2(n,slopes,intercepts,visible):
	for i in range(0,n):
		visible.append(True)
        for k in range(2, n):                                   #check visibility of all triplets where i<j<k
                for i in range(1, n-1):
			for j in range(0, n-2):
                                        if(j < i < k):
						YjYk = slopes[j]*(intercepts[j] - intercepts[k]) + intercepts[j]*(slopes[k] - slopes[j])
                                                #YiYk = slopes[i]*(intercepts[j] - intercepts[k]) + intercepts[i]*(slopes[k] - slopes[j])
						if( (slopes[j]*(YjYk) + intercepts[j]) > (slopes[i]*(YjYk) + intercepts[i])):
                                                        visible[i] = False

#def mergeVisible(L, R):
	 

	
def mergeVisibleRecursive(slopesLeft, interceptsLeft,visibleLeft,slopesRight,interceptsRight,visibleRight, i):
	a = len(slopesLeft)
	b = len(slopesRight) - 1
	if(i < a): 
		if (visibleLeft[i-1] == False):
			visibleLeft[i] = False
			z = i +1 
			mergeVisibleRecursive(slopesLeft,interceptsLeft,visibleLeft,slopesRight,interceptsRight,visibleRight,z)
		else:
			for k in range (0, b):
				j = i-1  
				YjYk = slopesLeft[j]*(interceptsLeft[j] - interceptsRight[k]) + interceptsLeft[j]*(slopesRight[k] - slopesLeft[j])
		#		YiYk = slopesLeft[i]*(interceptsLeft[j] - interceptsRight[k]) + interceptsLeft[i]*(slopesRight[k] - slopesLeft[j])
				if( (slopesLeft[j]*(YjYk) + interceptsLeft[j]) > (slopesLeft[i]*(YjYk) + interceptsLeft[i])):
					visibleLeft[i] = False
					break
			z = i+1
			mergeVisibleRecursive(slopesLeft,interceptsLeft,visibleLeft,slopesRight,interceptsRight,visibleRight,z)		
	if(i <= b):
		bi = b - i 
		if(visibleRight[bi+1] == False):
			visibleRight[bi] = False
			z = i+1
			mergeVisibleRecursive(slopesLeft,interceptsLeft,visibleLeft,slopesRight,interceptsRight,visibleRight,z)
		else:
			for j in range(0,a):
				k = bi+1
				YjYk = slopesLeft[j]*(interceptsLeft[j] - interceptsRight[k]) + interceptsLeft[j]*(slopesRight[k] - slopesLeft[j])
			#YiYk = slopesRight[bi]*(interceptsRight[j] - interceptsLeft[k]) + interceptsRight[bi]*(slopesLeft[k] - slopesRight[j])
				if((slopesLeft[j]*(YjYk) + interceptsLeft[j]) > (slopesRight[bi]*(YjYk) + interceptsRight[bi])):
					visibleRight[bi] = False
					break
			z = i+1
			mergeVisibleRecursive(slopesLeft, interceptsLeft,visibleLeft, slopesRight,interceptsRight,visibleRight,z)
	else:
		return

#slopesA =[-2,-1,0,1,2]
#interceptsA = [0,0,0,0,0]
#visibleA = [True, True, True, True, True] 

#slopesB = [3,4,5,6,7]
#interceptsB = [1,1,1,1,1]
#visibleB=[True, True, True, True, True] 

#a = len(slopesA) 
#b = len(slopesB) 
#mergeVisible(slopesA,intarceptsA,visibleA,slopesB,interceptsB,visibleB) 

l = []
r = []
genLines(num_lines,l)
genLines(num_lines,r)
for i in range (0,num_lines):
	print repr(l[i].m) + ',' + repr(l[i].b)
slopesN = [-2,-1,0,1,2,3,4,5,6,7]
interceptsN = [0,0,0,0,0,1,1,1,1,1]
visibleN = []
n = len(slopesN)
alg2(n,slopesN,interceptsN,visibleN)
print visibleN

slopesX = [-2,-1,0,1,2]
interceptsX = [0,0,0,0,0]
visibleX = [True, True, True, True, True]

slopesY = [3,4,5,6,7]
interceptsY = [1,1,1,1,1]
visibleY =[True, True, True, True, True]
mergeLines(l,r)
for i in range (0,num_lines):
	print P.vis 
mergeVisibleRecursive(slopesX,interceptsX,visibleX,slopesY,interceptsY,visibleY,1)
visibleX.extend(visibleY)
print visibleX
